/**
 * Tests for workspace handlers.
 *
 * Uses a mock jj runner to test handler logic without requiring
 * a real jj repository.
 */

import { describe, it, expect, vi, beforeEach } from "vitest";
import {
  WorkspaceCreateHandler,
  WorkspaceMergeHandler,
  WorkspaceCleanupHandler,
  emergencyWorkspaceCleanup,
  WS_CONTEXT,
  DEFAULT_WORKSPACE_PART,
  parseWorkspaceNames,
  sanitizeWorkspaceNamePart,
  uniquifyWorkspaceName,
  buildMergedHeadsRevset,
  type JjRunner,
} from "./workspace.js";
import { Context } from "./types.js";
import type { GraphNode, Graph } from "./types.js";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { mkdtemp, rm, readFile } from "node:fs/promises";

// ---------------------------------------------------------------------------
// Helpers
// ---------------------------------------------------------------------------

function makeGraph(name = "TestPipeline"): Graph {
  return {
    name,
    attrs: { goal: "test" },
    nodes: [],
    edges: [],
    node_defaults: {},
    edge_defaults: {},
  };
}

function makeNode(overrides: Partial<GraphNode> = {}): GraphNode {
  return {
    id: "ws_node",
    attrs: {},
    ...overrides,
  };
}

/** Regex fragment matching the hex suffix generated by uniquifyWorkspaceName. */
const HEX_SUFFIX = "[0-9a-f]{8}";

/** Matches a standalone hex suffix with optional collision counter. */
const HEX_SUFFIX_PATTERN = new RegExp(`^${HEX_SUFFIX}(?:-\\d+)?$`);

/** Build a regex matching a workspace name with the given prefix and hex suffix. */
function workspaceNamePattern(prefix: string, { withCollisionSuffix }: { withCollisionSuffix?: boolean } = {}): RegExp {
  const collision = withCollisionSuffix ? "-\\d+" : "(?:-\\d+)?";
  return new RegExp(`^${prefix}-${HEX_SUFFIX}${collision}$`);
}

/** Assert a value is a string and return it with narrowed type. */
function expectString(value: unknown): string {
  expect(typeof value).toBe("string");
  return value as string;
}

/** Create a mock jj runner that returns canned responses. */
function mockJj(responses: Record<string, string> = {}): JjRunner & { calls: string[][] } {
  const calls: string[][] = [];
  const runner = async (args: string[], cwd?: string): Promise<string> => {
    calls.push(args);
    // Match on first two args as the "command"
    const cmd = args.slice(0, 2).join(" ");
    if (cmd in responses) return responses[cmd];
    // Match on first arg
    if (args[0] in responses) return responses[args[0]];
    return "";
  };
  (runner as any).calls = calls;
  return runner as JjRunner & { calls: string[][] };
}

// ---------------------------------------------------------------------------
// parseWorkspaceNames
// ---------------------------------------------------------------------------

describe("parseWorkspaceNames", () => {
  it("parses template output with one name per line", () => {
    const output = "default\nfeature\n";
    const names = parseWorkspaceNames(output);
    expect(names).toEqual(new Set(["default", "feature"]));
  });

  it("returns empty set for empty string", () => {
    expect(parseWorkspaceNames("")).toEqual(new Set());
  });

  it("returns empty set for whitespace-only input", () => {
    expect(parseWorkspaceNames("   \n  \n\n  ")).toEqual(new Set());
  });

  it("trims whitespace and skips blank lines", () => {
    const output = "  default  \n\n  feature  \n  \n";
    const names = parseWorkspaceNames(output);
    expect(names).toEqual(new Set(["default", "feature"]));
  });

  it("handles a single workspace entry", () => {
    const output = "default\n";
    const names = parseWorkspaceNames(output);
    expect(names).toEqual(new Set(["default"]));
  });

  it("handles workspace names with dashes and numbers", () => {
    const output = "default\npipeline-my-feature-abc123\n";
    const names = parseWorkspaceNames(output);
    expect(names).toEqual(new Set(["default", "pipeline-my-feature-abc123"]));
  });

  it("skips lines that don't match valid workspace name pattern", () => {
    const output = "default\n\x1b[32mgarbage\x1b[0m\nfeature\n";
    const names = parseWorkspaceNames(output);
    expect(names).toEqual(new Set(["default", "feature"]));
  });
});

// ---------------------------------------------------------------------------
// sanitizeWorkspaceNamePart
// ---------------------------------------------------------------------------

describe("sanitizeWorkspaceNamePart", () => {
  it("lowercases and replaces non-alphanumeric chars with dashes", () => {
    expect(sanitizeWorkspaceNamePart("MyFeature")).toBe("myfeature");
    expect(sanitizeWorkspaceNamePart("My Feature")).toBe("my-feature");
    expect(sanitizeWorkspaceNamePart("hello_world")).toBe("hello-world");
  });

  it("strips leading and trailing dashes", () => {
    expect(sanitizeWorkspaceNamePart("---hello---")).toBe("hello");
    expect(sanitizeWorkspaceNamePart("  hello  ")).toBe("hello");
  });

  it("collapses consecutive dashes", () => {
    expect(sanitizeWorkspaceNamePart("a---b---c")).toBe("a-b-c");
    expect(sanitizeWorkspaceNamePart("hello!!!world")).toBe("hello-world");
  });

  it("truncates to 48 chars without trailing dash", () => {
    const long = "a".repeat(60);
    const result = sanitizeWorkspaceNamePart(long);
    expect(result.length).toBeLessThanOrEqual(48);
    expect(result).toBe("a".repeat(48));
  });

  it("strips trailing dash after truncation", () => {
    // 47 'a's then a space then more text — the space becomes a dash at position 48
    const input = "a".repeat(47) + " bbb";
    const result = sanitizeWorkspaceNamePart(input);
    expect(result.length).toBeLessThanOrEqual(48);
    expect(result).not.toMatch(/-$/);
  });

  it("returns 'pipeline' for empty input", () => {
    expect(sanitizeWorkspaceNamePart("")).toBe(DEFAULT_WORKSPACE_PART);
  });

  it("returns DEFAULT_WORKSPACE_PART for all-special-char input", () => {
    expect(sanitizeWorkspaceNamePart("!!!@@@###")).toBe(DEFAULT_WORKSPACE_PART);
    expect(sanitizeWorkspaceNamePart("---")).toBe(DEFAULT_WORKSPACE_PART);
    expect(sanitizeWorkspaceNamePart("   ")).toBe(DEFAULT_WORKSPACE_PART);
  });

  it("preserves digits", () => {
    expect(sanitizeWorkspaceNamePart("feature123")).toBe("feature123");
    expect(sanitizeWorkspaceNamePart("42")).toBe("42");
  });

  it("handles mixed unicode and special characters", () => {
    const result = sanitizeWorkspaceNamePart("café résumé");
    expect(result).toBe("caf-r-sum");
  });
});

// ---------------------------------------------------------------------------
// uniquifyWorkspaceName
// ---------------------------------------------------------------------------

describe("uniquifyWorkspaceName", () => {
  it("returns base when no collision and alwaysSuffix=false", () => {
    const existing = new Set(["other-workspace"]);
    const result = uniquifyWorkspaceName("my-ws", existing, false);
    expect(result).toBe("my-ws");
  });

  it("appends suffix when base collides and alwaysSuffix=false", () => {
    const existing = new Set(["my-ws"]);
    const result = uniquifyWorkspaceName("my-ws", existing, false);
    expect(result).toMatch(workspaceNamePattern("my-ws"));
    expect(result).not.toBe("my-ws");
  });

  it("appends suffix when alwaysSuffix=true even without collision", () => {
    const existing = new Set<string>();
    const result = uniquifyWorkspaceName("my-ws", existing, true);
    expect(result).toMatch(workspaceNamePattern("my-ws"));
    expect(result).not.toBe("my-ws");
  });

  it("increments numeric suffix on repeated collisions", () => {
    // Use a dynamic Set that reports the first two candidates as collisions,
    // forcing the while-loop to increment the numeric suffix.
    let callCount = 0;
    const dynamicSet = {
      has(name: string): boolean {
        callCount++;
        // First three checks collide: base, base-suffix, base-suffix-2
        return callCount <= 3;
      },
    } as Set<string>;
    const result = uniquifyWorkspaceName("my-ws", dynamicSet, false);
    // Should have gone through the loop and appended a numeric suffix
    expect(result).toMatch(workspaceNamePattern("my-ws", { withCollisionSuffix: true }));
    expect(callCount).toBeGreaterThanOrEqual(3);
  });

  it("throws after exceeding max attempts on persistent collisions", () => {
    // A Set whose has() always returns true forces unbounded collisions
    const alwaysCollides = { has: () => true } as Set<string>;
    expect(() => uniquifyWorkspaceName("my-ws", alwaysCollides, false)).toThrow(
      /Could not generate unique workspace name after 1000 attempts/,
    );
  });

  it("works with empty existing names set and alwaysSuffix=false", () => {
    const result = uniquifyWorkspaceName("base", new Set(), false);
    expect(result).toBe("base");
  });

  it("generates unique results across sequential calls", () => {
    const existing = new Set<string>();
    const results: string[] = [];
    for (let i = 0; i < 5; i++) {
      const name = uniquifyWorkspaceName("ws", existing, true);
      existing.add(name);
      results.push(name);
    }
    // All results should be unique
    expect(new Set(results).size).toBe(5);
  });
});

// ---------------------------------------------------------------------------
// buildMergedHeadsRevset
// ---------------------------------------------------------------------------

describe("buildMergedHeadsRevset", () => {
  it("builds revset with validated short id", () => {
    const { head, revset } = buildMergedHeadsRevset("abc123");
    expect(head).toBe("abc123");
    expect(revset).toBe("heads(descendants(abc123) & mutable() & ~abc123)");
  });

  it("trims surrounding whitespace", () => {
    const { head, revset } = buildMergedHeadsRevset("  abc123  \n");
    expect(head).toBe("abc123");
    expect(revset).toBe("heads(descendants(abc123) & mutable() & ~abc123)");
  });

  it("allows @ fallback token", () => {
    const { head, revset } = buildMergedHeadsRevset("@");
    expect(head).toBe("@");
    expect(revset).toBe("heads(descendants(@) & mutable() & ~@)");
  });

  it("rejects unexpected revset characters", () => {
    expect(() => buildMergedHeadsRevset("abc123) | all()")).toThrow(/Invalid revision token format/);
  });
});

// ---------------------------------------------------------------------------
// WorkspaceCreateHandler
// ---------------------------------------------------------------------------

describe("WorkspaceCreateHandler", () => {
  it("creates a workspace and stores metadata in context", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ attrs: { workspace_name: "my-feature" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.NAME]).toBe("my-feature");
      expect(outcome.context_updates![WS_CONTEXT.PATH]).toBe("/tmp/test-repo-ws-my-feature");
      expect(outcome.context_updates![WS_CONTEXT.BASE_COMMIT]).toBe("abc12345");
      expect(outcome.context_updates![WS_CONTEXT.REPO_ROOT]).toBe("/tmp/test-repo");

      // Should have called workspace add
      const addCall = jj.calls.find((c) => c[0] === "workspace" && c[1] === "add");
      expect(addCall).toBeDefined();
      expect(addCall).toContain("my-feature");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("sanitizes user-supplied workspace_name before use", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      // Path traversal and shell metacharacters should be stripped
      const node = makeNode({ attrs: { workspace_name: "../../etc; rm -rf /" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      const name = expectString(outcome.context_updates![WS_CONTEXT.NAME]);

      // Should be sanitized to a safe slug with no path separators or shell chars
      expect(name).not.toMatch(/[./;\\]/);
      expect(name).toBe("etc-rm-rf");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("auto-generates workspace name from graph name", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode(); // no workspace_name

      const outcome = await handler.execute(node, context, makeGraph("FeatureImpl"), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      const name = expectString(outcome.context_updates![WS_CONTEXT.NAME]);

      // Verify deterministic prefix from sanitizeWorkspaceNamePart
      const expectedPrefix = `pipeline-${sanitizeWorkspaceNamePart("FeatureImpl")}`;
      expect(expectedPrefix).toBe("pipeline-featureimpl");
      expect(name.startsWith(`${expectedPrefix}-`)).toBe(true);

      // Verify the suffix is valid 8-char hex (from randomBytes(4))
      const suffix = name.slice(expectedPrefix.length + 1);
      expect(suffix).toMatch(HEX_SUFFIX_PATTERN);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("uses fallback name when graph name sanitizes to empty", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode(); // no workspace_name — relies on graph name

      const outcome = await handler.execute(node, context, makeGraph("!!!@@@###"), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      const name = expectString(outcome.context_updates![WS_CONTEXT.NAME]);

      // sanitizeWorkspaceNamePart("!!!@@@###") returns DEFAULT_WORKSPACE_PART (fallback)
      const expectedPrefix = `pipeline-${DEFAULT_WORKSPACE_PART}-`;
      expect(name.startsWith(expectedPrefix)).toBe(true);

      const suffix = name.slice(expectedPrefix.length);
      expect(suffix).toMatch(HEX_SUFFIX_PATTERN);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("auto-generates different names across runs", async () => {
    const names: string[] = [];
    for (let i = 0; i < 3; i++) {
      const jj = mockJj({
        "root": "/tmp/test-repo",
        "workspace list": "default",
        "log": "abc12345",
        "workspace add": "",
      });

      const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
      try {
        const handler = new WorkspaceCreateHandler(jj);
        const context = new Context();
        const node = makeNode();
        const outcome = await handler.execute(node, context, makeGraph("SameName"), logsRoot);
        expect(outcome.status).toBe("success");
        expect(outcome.context_updates).toBeDefined();
        names.push(expectString(outcome.context_updates![WS_CONTEXT.NAME]));
      } finally {
        await rm(logsRoot, { recursive: true, force: true });
      }
    }
    // All three runs should produce different names
    expect(new Set(names).size).toBe(3);
  });

  it("auto-suffixes workspace_name when it already exists", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default\nmy-feature",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ attrs: { workspace_name: "my-feature" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      const name = expectString(outcome.context_updates![WS_CONTEXT.NAME]);

      // Verify the generated name differs from the colliding existing name
      expect(name).not.toBe("my-feature");

      // Verify the configured name is preserved as the prefix
      expect(name.startsWith("my-feature-")).toBe(true);

      // Verify the suffix is valid 8-char hex
      const suffix = name.slice("my-feature-".length);
      expect(suffix).toMatch(HEX_SUFFIX_PATTERN);

      const addCall = jj.calls.find((c) => c[0] === "workspace" && c[1] === "add");
      expect(addCall).toBeDefined();
      expect(addCall).toContain(name);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails gracefully when jj workspace add errors", async () => {
    const baseJj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
    });
    // Wrap the mock so `workspace add` throws, simulating a real jj failure
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[], cwd?: string) => {
        if (args[0] === "workspace" && args[1] === "add") {
          baseJj.calls.push(args);
          throw new Error("fatal: disk full");
        }
        return baseJj(args, cwd);
      },
      { calls: baseJj.calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ attrs: { workspace_name: "my-feature" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("Failed to create workspace");
      expect(outcome.failure_reason).toContain("disk full");
      // Should not have set any context updates on failure
      expect(outcome.context_updates).toBeUndefined();
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("retries with a new name on workspace name collision", async () => {
    let addAttempts = 0;
    const baseJj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
    });
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[], cwd?: string) => {
        if (args[0] === "workspace" && args[1] === "add") {
          baseJj.calls.push(args);
          addAttempts++;
          if (addAttempts === 1) {
            throw new Error("Error: Workspace already exists");
          }
          return ""; // succeed on second attempt
        }
        return baseJj(args, cwd);
      },
      { calls: baseJj.calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ attrs: { workspace_name: "my-feature" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(addAttempts).toBe(2);
      // Should have re-read the workspace list between attempts
      const listCalls = jj.calls.filter((c) => c[0] === "workspace" && c[1] === "list");
      expect(listCalls.length).toBeGreaterThanOrEqual(2);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails after exhausting collision retries", async () => {
    const baseJj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
    });
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[], cwd?: string) => {
        if (args[0] === "workspace" && args[1] === "add") {
          baseJj.calls.push(args);
          throw new Error("Error: Workspace already exists");
        }
        return baseJj(args, cwd);
      },
      { calls: baseJj.calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ attrs: { workspace_name: "my-feature" } });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("collision persisted after");
      expect(outcome.context_updates).toBeUndefined();
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("writes workspace.json to the logs directory", async () => {
    const jj = mockJj({
      "root": "/tmp/test-repo",
      "workspace list": "default",
      "log": "abc12345",
      "workspace add": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCreateHandler(jj);
      const context = new Context();
      const node = makeNode({ id: "setup", attrs: { workspace_name: "log-test" } });

      await handler.execute(node, context, makeGraph(), logsRoot);

      const logFile = JSON.parse(await readFile(join(logsRoot, "setup", "workspace.json"), "utf-8"));
      expect(logFile.name).toBe("log-test");
      expect(logFile.base_commit).toBe("abc12345");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });
});

// ---------------------------------------------------------------------------
// WorkspaceMergeHandler
// ---------------------------------------------------------------------------

describe("WorkspaceMergeHandler", () => {
  function contextWithWorkspace(): Context {
    const ctx = new Context();
    ctx.set(WS_CONTEXT.NAME, "my-feature");
    ctx.set(WS_CONTEXT.PATH, "/tmp/test-repo-ws-my-feature");
    ctx.set(WS_CONTEXT.REPO_ROOT, "/tmp/test-repo");
    ctx.set(WS_CONTEXT.BASE_COMMIT, "abc12345");
    return ctx;
  }

  it("rebases workspace commits onto default", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit3\ncommit2\ncommit1";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "@" &&
          args.includes("--limit")
        ) {
          return "default1234";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "heads(descendants(default1234) & mutable() & ~default1234)"
        ) {
          return "merged9999\n";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "@" && args[3] === "-d" && args[4] === "merged9999") {
          return "";
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();
      const node = makeNode({ id: "merge" });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.notes).toBe(
        'Merged 3 commit(s) from workspace "my-feature" and moved @ onto merged tip merged9999.',
      );
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGED]).toBe("true");

      // Should have called rebase with the earliest (last) commit
      const rebaseCall = jj.calls.find((c) => c[0] === "rebase" && c[2] === "commit1");
      expect(rebaseCall).toBeDefined();
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("falls back to @ when default head lookup fails and still merges", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit3\ncommit2\ncommit1";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "@" &&
          args.includes("--limit")
        ) {
          throw new Error("default head lookup failed");
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "heads(descendants(@) & mutable() & ~@)"
        ) {
          return "merged1234\n";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "@" && args[3] === "-d" && args[4] === "merged1234") {
          return "";
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();
      const node = makeNode({ id: "merge-fallback" });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.notes).toContain("moved @ onto merged tip merged1234");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGED]).toBe("true");
      expect(context.logs.some((entry) => entry.includes("failed to capture default head before merge"))).toBe(true);

      const mergeLog = JSON.parse(await readFile(join(logsRoot, "merge-fallback", "merge.json"), "utf-8"));
      expect(mergeLog).toHaveProperty("merged_tip");
      expect(mergeLog).toHaveProperty("default_head_before_merge");
      expect(mergeLog).toHaveProperty("moved_default_head");
      expect(mergeLog.default_head_before_merge).toBe("@");
      expect(mergeLog.merged_tip).toBe("merged1234");
      expect(mergeLog.moved_default_head).toBe(true);

      // Ensure fallback path was exercised and did not abort merge.
      const headLookupCall = jj.calls.find(
        (c) => c[0] === "log" && c[1] === "-r" && c[2] === "@" && c.includes("--limit"),
      );
      const moveDefaultCall = jj.calls.find(
        (c) => c[0] === "rebase" && c[1] === "-s" && c[2] === "@" && c[3] === "-d" && c[4] === "merged1234",
      );
      expect(headLookupCall).toBeDefined();
      expect(moveDefaultCall).toBeDefined();
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("succeeds without moving @ when merged heads query is empty", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit2\ncommit1";
        }

        if (args[0] === "log" && args[1] === "-r" && args[2] === "@" && args.includes("--limit")) {
          return "default1234";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "heads(descendants(default1234) & mutable() & ~default1234)"
        ) {
          return "\n";
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();
      const node = makeNode({ id: "merge-empty-heads" });

      const outcome = await handler.execute(node, context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.notes).toBe('Merged 2 commit(s) from workspace "my-feature".');
      expect(outcome.notes).not.toContain("moved @ onto merged tip");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGED]).toBe("true");

      const moveDefaultCall = jj.calls.find(
        (c) => c[0] === "rebase" && c[1] === "-s" && c[2] === "@",
      );
      expect(moveDefaultCall).toBeUndefined();

      const mergeLog = JSON.parse(await readFile(join(logsRoot, "merge-empty-heads", "merge.json"), "utf-8"));
      expect(mergeLog).toHaveProperty("merged_tip");
      expect(mergeLog).toHaveProperty("default_head_before_merge");
      expect(mergeLog).toHaveProperty("moved_default_head");
      expect(mergeLog.default_head_before_merge).toBe("default1234");
      expect(mergeLog.merged_tip).toBeNull();
      expect(mergeLog.moved_default_head).toBe(false);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("uses the first merged head deterministically when multiple are returned", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit2\ncommit1";
        }

        if (args[0] === "log" && args[1] === "-r" && args[2] === "@" && args.includes("--limit")) {
          return "default1234";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "heads(descendants(default1234) & mutable() & ~default1234)"
        ) {
          return "mergedA\nmergedB\n";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "@" && args[3] === "-d") {
          return "";
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();

      const outcome = await handler.execute(makeNode({ id: "merge-multiple-heads" }), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.notes).toContain("merged tip mergedA");

      const moveDefaultCall = jj.calls.find(
        (c) => c[0] === "rebase" && c[1] === "-s" && c[2] === "@" && c[3] === "-d",
      );
      expect(moveDefaultCall).toBeDefined();
      expect(moveDefaultCall![4]).toBe("mergedA");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("succeeds with no commits to merge", async () => {
    const jj = mockJj({
      "log": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();

      const outcome = await handler.execute(makeNode(), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.notes).toContain("No workspace-specific commits");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails when no workspace context exists", async () => {
    const jj = mockJj();
    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = new Context(); // no workspace set

      const outcome = await handler.execute(makeNode(), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("No workspace context");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails when moving @ onto merged tip reports conflicts", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit2\ncommit1";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "@" &&
          args.includes("--limit")
        ) {
          return "default1234";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "rebased";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "heads(descendants(default1234) & mutable() & ~default1234)"
        ) {
          return "merged5678\n";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "@" && args[3] === "-d" && args[4] === "merged5678") {
          throw new Error("working copy has conflicts");
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();

      const outcome = await handler.execute(makeNode({ id: "merge-move-conflict" }), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toBe(
        "Merge conflicts detected while moving default workspace head. Resolve conflicts and retry.",
      );
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGE_CONFLICTS]).toBe("true");
      expect(context.logs.some((entry) => entry.includes("failed to move default workspace head onto merged tip"))).toBe(true);
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails when default head format is unexpected for revset construction", async () => {
    const calls: string[][] = [];
    const jj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[]) => {
        calls.push(args);

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "ancestors(my-feature@) & mutable() & ~ancestors(default@)"
        ) {
          return "commit1";
        }

        if (
          args[0] === "log" &&
          args[1] === "-r" &&
          args[2] === "@" &&
          args.includes("--limit")
        ) {
          return "bad!head";
        }

        if (args[0] === "rebase" && args[1] === "-s" && args[2] === "commit1" && args[3] === "-d" && args[4] === "@") {
          return "";
        }

        return "";
      },
      { calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(jj);
      const context = contextWithWorkspace();

      const outcome = await handler.execute(makeNode({ id: "merge-invalid-head" }), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("Invalid revision token format");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGE_CONFLICTS]).toBe("true");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("reports failure on rebase conflict", async () => {
    const jj = mockJj({
      "log": "commit1",
    });
    // Override rebase to throw (simulating conflict)
    const originalRunner = jj;
    const conflictJj: JjRunner & { calls: string[][] } = Object.assign(
      async (args: string[], cwd?: string) => {
        if (args[0] === "rebase") {
          throw new Error("conflict in file.ts");
        }
        return originalRunner(args, cwd);
      },
      { calls: originalRunner.calls },
    );

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceMergeHandler(conflictJj);
      const context = contextWithWorkspace();

      const outcome = await handler.execute(makeNode(), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("Rebase failed");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.MERGE_CONFLICTS]).toBe("true");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });
});

// ---------------------------------------------------------------------------
// WorkspaceCleanupHandler
// ---------------------------------------------------------------------------

describe("WorkspaceCleanupHandler", () => {
  it("forgets workspace and marks cleanup complete", async () => {
    const jj = mockJj({
      "workspace forget": "",
    });

    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCleanupHandler(jj);
      const context = new Context();
      context.set(WS_CONTEXT.NAME, "my-feature");
      context.set(WS_CONTEXT.PATH, "/tmp/nonexistent-ws-my-feature");
      context.set(WS_CONTEXT.REPO_ROOT, "/tmp/test-repo");

      const outcome = await handler.execute(makeNode({ id: "cleanup" }), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("success");
      expect(outcome.context_updates).toBeDefined();
      expect(outcome.context_updates![WS_CONTEXT.CLEANED_UP]).toBe("true");

      // Should have called workspace forget
      const forgetCall = jj.calls.find((c) => c[0] === "workspace" && c[1] === "forget");
      expect(forgetCall).toBeDefined();
      expect(forgetCall).toContain("my-feature");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("refuses to clean up the default workspace", async () => {
    const jj = mockJj();
    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCleanupHandler(jj);
      const context = new Context();
      context.set(WS_CONTEXT.NAME, "default");

      const outcome = await handler.execute(makeNode(), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("default workspace");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });

  it("fails when no workspace name in context", async () => {
    const jj = mockJj();
    const logsRoot = await mkdtemp(join(tmpdir(), "ws-test-"));
    try {
      const handler = new WorkspaceCleanupHandler(jj);
      const context = new Context();

      const outcome = await handler.execute(makeNode(), context, makeGraph(), logsRoot);

      expect(outcome.status).toBe("fail");
      expect(outcome.failure_reason).toContain("No workspace name");
    } finally {
      await rm(logsRoot, { recursive: true, force: true });
    }
  });
});

// ---------------------------------------------------------------------------
// emergencyWorkspaceCleanup
// ---------------------------------------------------------------------------

describe("emergencyWorkspaceCleanup", () => {
  it("calls workspace forget when workspace exists in context", async () => {
    const jj = mockJj({
      "workspace forget": "",
    });

    const context = new Context();
    context.set(WS_CONTEXT.NAME, "my-feature");
    context.set(WS_CONTEXT.PATH, "/tmp/nonexistent-ws-my-feature");
    context.set(WS_CONTEXT.REPO_ROOT, "/tmp/test-repo");

    await emergencyWorkspaceCleanup(context, jj);

    const forgetCall = jj.calls.find((c) => c[0] === "workspace" && c[1] === "forget");
    expect(forgetCall).toBeDefined();
  });

  it("does nothing when no workspace in context", async () => {
    const jj = mockJj();
    const context = new Context();

    await emergencyWorkspaceCleanup(context, jj);

    expect(jj.calls).toHaveLength(0);
  });

  it("does nothing when already cleaned up", async () => {
    const jj = mockJj();
    const context = new Context();
    context.set(WS_CONTEXT.NAME, "my-feature");
    context.set(WS_CONTEXT.CLEANED_UP, "true");

    await emergencyWorkspaceCleanup(context, jj);

    expect(jj.calls).toHaveLength(0);
  });

  it("does nothing for the default workspace", async () => {
    const jj = mockJj();
    const context = new Context();
    context.set(WS_CONTEXT.NAME, "default");

    await emergencyWorkspaceCleanup(context, jj);

    expect(jj.calls).toHaveLength(0);
  });

  it("swallows errors silently", async () => {
    const jj: JjRunner = async () => { throw new Error("jj not found"); };
    const context = new Context();
    context.set(WS_CONTEXT.NAME, "my-feature");
    context.set(WS_CONTEXT.REPO_ROOT, "/tmp/test-repo");

    // Should not throw
    await emergencyWorkspaceCleanup(context, jj);
  });
});

// ---------------------------------------------------------------------------
// Integration: workspace handlers resolve via HandlerRegistry
// ---------------------------------------------------------------------------

describe("HandlerRegistry workspace integration", () => {
  it("resolves workspace.create, workspace.merge, workspace.cleanup types", async () => {
    // Import here to avoid circular deps in test setup
    const { HandlerRegistry } = await import("./handlers.js");
    const jj = mockJj();

    const registry = new HandlerRegistry({ jjRunner: jj });

    const createNode: GraphNode = { id: "ws", attrs: { type: "workspace.create" } };
    const mergeNode: GraphNode = { id: "ws", attrs: { type: "workspace.merge" } };
    const cleanupNode: GraphNode = { id: "ws", attrs: { type: "workspace.cleanup" } };

    expect(registry.resolve(createNode)).toBeInstanceOf(WorkspaceCreateHandler);
    expect(registry.resolve(mergeNode)).toBeInstanceOf(WorkspaceMergeHandler);
    expect(registry.resolve(cleanupNode)).toBeInstanceOf(WorkspaceCleanupHandler);
  });
});
